## TODO
- 고정된 시간 만들기 (이 시간에 무엇을 할지 확정)


#### 친구 관련 이슈 정리

> Q1. 친구와 친구의 친구들, 방문자수가 많으면 많을수록 너무 한꺼번에 많은 데이터를 처리할 것 같은데요.
 성능에 영향을 덜 줄수 있는 다른 방법도 고민해보면 어떨까요?
예를들어 전체를 다 계산하지 않고 후보에 대해서 일부만 제공한다던가요.  (https://github.com/woowacourse/miniprojects-2019/pull/29#discussion_r319721338)

```
되게 많이 공감이 되었던 부분입니다. 특히 친구가 100명정도 된다고 할 경우, 친구의 친구의 수는 100만명 단위여서요. (특히 친구가 많은 사람들이라면...)  
특히 각 유저마다 필요한 데이터여서 캐시를 해놓기에도 부담이 클 듯 하구요

즉.. 전체 데이터를 사용하려면.. 시간이든 공간이든 한 쪽은 부담이 매우 클 것 같습니다. 일단 친구 후보 데이터 자체가 크네요.. (혹시나 방법이 있다면.. 실제 서비스와는 다른 서버? 같은 곳에서 돌려서.. 중요한 서비스에는 영향을 미치지 않도록 하면서 전체 데이터를 사용하는 정도 일 것 같구요. 전체 데이터를 사용하면서 더 좋은 방법이 있을까요??)

그래서 예를 들어주신 것처럼.. 일부에 대해서 고민하는 방식을 사용해야 할 것 같습니다.

데이터의 일부분만 사용할 때 고민되는 부분은.. 후보를 얻는 이유가 랭킹을 제공하기 때문입니다. (물론 전체 데이터로부터 정확한 랭킹 순서가 필요한게 아니라고 한다면 일부분만 잘 찾아와도 좋을 것 같습니다..!)  

지금 생각나는 방식은 일단 샘플을 잘 골라내는 것 (페이징 처럼.. 특정 친구 수 만큼 찾아와서.. 그 안에서 랭킹을 내서 보여주는 방식일 것 같아요) 정도 인 것 같습니다.  

이렇게 랭킹을 매겨야 하는데 전체 데이터를 쓰지 못할 경우에 사용할 수 있는 방식이 있을까요? (키워드 자체가 생각이 안납니다...ㅠ)
먼가 구글 같은 경우가 비슷한 경우일지도 모르겠네요..

아니면 화투님 같은 경우는 어떻게 접근하실 것 같은지 의견을 말씀해 주실수 있을까요?? :)
```

> Q2. 방문자 카운터가 배포시마다 초기화가 되거나, 서버마다 다른 데이터를 보여 줄 수 있겠네요. :)
지금에 고칠건 아니지만 그냥 한번 이런 경우 어떻게 하면 좋았을지에 대해 고민해보는것도 좋을 것 같습니다.  (https://github.com/woowacourse/miniprojects-2019/pull/29#discussion_r319721455)

```
이 부분도.. 문제가 있다고 생각했는데 피드백 주셔서 감사했습니다..!  
체스때 피드백 주신 부분과도 겹쳐있는데.. DB 처럼 모든 서버가 공유하지 못하는 자원을 사용하고 있습니다.  

방문자를 카운팅하는 것은.. 실제 서비스하고 싶은 주요 기능보단 부가 기능 같아서 일단 db에 직접 저장하는 것은 부담이 아닌가 했었습니다.  
그래서 메모리 상에서 카운팅을 하고 나중에 (특정 주기로) 비휘발성인 곳에 적어 놓는 것을 생각했습니다.  
지금 생각하는 해결 방식은 캐시입니다. 글로벌 캐시(다른 서버들에게서도 공유되는)를 사용하려고 하고 있습니다. (레디스라는게 있다는데 좀 살펴보려합니다.)  

한편으로는 제이슨께 로그 형태로 데이터를 수집하고 나중에 해당 데이터를 가공하는 형태로도 정보를 수집하는 형태도 있다고 들었습니다. (실시간으로 카운팅된 정보가 필요할 것 같지 않아서.. 나중에 가공하는 방식을 생각하면 많은 방법이 존재할 것 같네요)  


서비스를 운영하는 기업의 경우 데이터를 쌓는 부분이 필수 일 것 같습니다.. 혹시 일하시는 곳이나 아시는 곳에선 어떤 식으로 필요한 데이터를 수집하는지, 어떻게 사용하는지 알 수 있을까요??

현재는 인터셉터를 사용해서 카운팅을 하고 있는데... 이 위치에서 카운팅 정보를 수집하는게 올바를까 싶기도 하고요...
로그를 남기는 경우, 운영 코드 내부에서 로그로 데이터를 수집하면 불필요한 로직이 보이는 것 같아서.. 다른 곳 (ex. 데코레이터 패턴 처럼.. 실제 서비스 코드에서는 보이지는 않지만.. 함께 호출되는 곳) 에서 적는게 좋을 것도 같구요

정리하면..
1. 어떤 위치에서 정보를 수집하는게 좋을지
2. 어떤 형태로 정보를 수집하면 좋을지
로 볼 수 있을 것 같아요
```

> Q3. MutualFriendWithVisitorRankingStrategy, MutualFriendRankingStrategy 둘 다 같은 역할의 전략으로 보이는데 공통 인터페이스로 추출해보면 어떨까요? 

```
블로그때 피드백 주신 @Qualifier 를 사용해보려고 합니다..! 추상화할 인터페이스를 고민하게 되네요ㅎ
```

> Q4. friendCandidateFactory.createCandidates 에서 이미 한번씩 대량으로 친구 정보를 가져오는데
여기에서도 다시 한번 대량으로 조회하네요.
이 점도 한번 고민해보면 좋을 것 같아요. (https://github.com/woowacourse/miniprojects-2019/pull/29#discussion_r319721923)

```
이 부분은 좀 더 고민해보겠습니다..!  (처음에는 최대한 독립적으로 생각해보려고 했었는데.. 그러다보니 합칠 때 이런 형태가 되었습니다.)  
```


#### 로그백 관련 정리
- root 란 무엇일까? 왜 기존의 로거랑 겹치는 부분이 발생할까? 어떻게 팀에서 관리하면 좋을까?

일단 어떤게 문제?? (중복되어서 나오는 로그가 존재 + 원하는 로그 부분이 안 나오는 경우)

```java
 // print internal state
 LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
 StatusPrinter.print(lc);

 // 이렇게 logback 을 진단할 수 있음..!! (확인하는 습관을 가져야함...)
```

[https://logback.qos.ch/codes.html] layout 대신에 encoder


```xml
For example, the PatternLayout with the conversion pattern "%-4relative [%thread] %-5level %logger{32} - %msg%n" will output something akin to:

176  [main] DEBUG manual.architecture.HelloWorld2 - Hello world.

The first field is the number of milliseconds elapsed since the start of the program. The second field is the thread making the log request. The third field is the level of the log request. The fourth field is the name of the logger associated with the log request. The text after the '-' is the message of the request.

```
---

### 오늘 좋았던 점

### 오늘 아쉬웠던 점


---

### log
로그백 파악하기
[13:30] 피드백 관련 질문 정리
로그백 설정하기



친구추가 위치에서 검색할때 깨짐
