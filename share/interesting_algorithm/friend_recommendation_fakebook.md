### 친구추천

#### 배경
Fakebook 은 친구 기반으로 정보공유를 하기 위한 앱!
- 그런데 친구 추가하기가 넘나 힘들다..
    - 그나마 쿠기가 추가해준 친구 자동 검색이 있어서지...

목적
- 친구추천: 친구였으면 하는 사람 위주로 알려주자
    - 그래야 사용자가 원하는 정보들로 타임라인 등이 구성될테니
    - 일단 친구가 되어야 관련된 행위들을 할 수 있으니 (글쓰기, 댓글, 메신저, 알림 등)

친구를 그러면 어떤 기준으로 추천해줄까요?
- 함께아는 친구 (Facebook 에 영향을 많이 받았다 ㅠㅎ, 싸이월드 촌수도)
- 내 페이지를 방문한 기록 (관심있는 이성친구 페이지에 내가 뜰 수도 있는 이유)

---------

함께아는 친구 구하기
    // A, B 는 서로 친구가 아님
    A와 B 가 존재한다고 하면 'A_친구들 교집합 B_친구들' 가 함께아는 친구!

    O(A_친구들 + B_친구들) 정도의 비용으로 구할 수 있다..!

---------

> (A, B) 가 주어졌을 때 함께하는 친구를 구할 수 있는데... (A, B) 쌍은 어떻게 구하나요??

    Facebook_전체사용자 == N 이라고 하면  
    가능한 (A, B) 쌍의 수 == O(N ^ 2) 이다... ㄷ   

    각 쌍에 대해서 함께하는 친구 정보들을 구하면.. O(N ^ 2) * O(A_친구들 + B_친구들)  

    Facebook_전체사용자 가 1000명만 되도... 쥬륵..   

-----------

> 꼭 모든 사용자에 대해서 (A, B) 쌍을 확인해야 할까요?

    다행히 우리는 함께아는 친구가 1명이라도 있는 관계에 대해서만 알고싶다..!

    (A, B) 가 C 를 함께 알고 있다고 하자  
    그러면 A - C - B 로 표현할 수 있다!  

    함께아는 친구가 1명이라도 있음 == 친구의 친구인 관계  

    즉 A 를 고정한다고 하면..  
    B는 'A의 친구의 친구' 인 애들까지만 확인해주면 된다..!  

    가능한 (A, B) 쌍의 수 == O(N_친구들의수 ^ 2) 이다

    모든 사람들이 'N_친구수' 정도의 친구를 가진다면
    O(N_친구수 ^ 2) * O(A_친구수 + B_친구수) == O(N_친구수 ^ 3)

-----------

> 친구의 친구를 구할 때.. 유용한 정보를 저장해놓으면 좀 더 최적화 할 수 있지 않을까?

    친구 == directFriend  
    친구의 친구 == indirectFriend 라고 하자  

    그러면 특정한 '친구의 친구'를 구하는 과정은  
```
for(나의 친구들) {
    친구A
    for(친구A의 친구들) {

    }
}
```


    그런데 함께아는 친구의 개념을 생각해보자  
    한 번 그려보면 아래와 같은 그림이 그려진다  
```
나 - 친구1 - 친구의 친구  
  \ 친구2 /  
```

    즉.. '친구의 친구'를 구할 때.. 그 도중에 있던 친구1,2 ... 들을 저장해놓으면 '함께 아는 친구'인 것이다..!  

    이 경우 O(N_친구수 ^ 2) 의 복잡도가 될 수 있다. (도중의 친구 정도를 해시맵을 통해서 저장한다고 하면) 

